"""
This security layer inadequately handles A/B storage for files in RepyV2.

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
    """ 
TYPE="type"
ARGS="args"
RETURN="return"
EXCP="exceptions"
TARGET="target"
FUNC="func"
OBJC="objc"

mycontext['lock'] = createlock()

class ABFile():

  def __init__(self,filename,create):
    
    # globals
    mycontext['lock'].acquire(True)
    mycontext['debug'] = False   
    # local (per object) reference to the underlying file
    self.Afn = filename+'.a'
    self.Bfn = filename+'.b'

    # make the files and add 'SE' to the readat file...
    if create:     
       self.Afile = openfile(self.Afn,create)
       self.Bfile = openfile(self.Bfn,create)
       self.Afile.writeat('SE',0)
    else:
       self.Afile = openfile(self.Afn,create)
       self.Bfile = openfile(self.Bfn,create)

           
  def writeat(self,data,offset):
    # Write the requested data to the B file using the sandbox's writeat call
    if self.Bfile.readat(None, 0) == "":
       self.Bfile.writeat(data,0)
    else:
       self.Bfile.writeat(data,offset)     
    
  def readat(self,bytes,offset):
    # Read from the A file using the sandbox's readat...
    return self.Afile.readat(bytes,offset)

  def close(self):

  #When close() is called on the file, if both filename.a and filename.b are valid, the original file's data is replaced with the data of filename.b. If filename.b is not valid, no changes are made.

     BContents = self.Bfile.readat(None,0)
     AContents = self.Afile.readat(None,0)
     if (BContents.startswith("S") and BContents.endswith("E")):
        self.Afile.close()
        removefile(self.Afn)
        self.Afile = openfile(self.Afn, True)
        self.Afile.writeat(BContents, 0)
     else:
        removefile(self.Bfn)
	
     self.Afile.close()
     self.Bfile.close()
     
     mycontext['lock'].release()


def ABopenfile(filename, create):
  return ABFile(filename,create)

# The code here sets up type checking and variable hiding for you.  You
# should not need to change anything below here.
sec_file_def = {"obj-type":ABFile,
                "name":"ABFile",
                "writeat":{"type":"func","args":(str,int),"exceptions":Exception,"return":(int,type(None)),"target":ABFile.writeat},
                "readat":{"type":"func","args":((int,type(None)),(int)),"exceptions":Exception,"return":str,"target":ABFile.readat},
                "close":{"type":"func","args":None,"exceptions":None,"return":(bool,type(None)),"target":ABFile.close}
           }

CHILD_CONTEXT_DEF["ABopenfile"] = {TYPE:OBJC,ARGS:(str,bool),EXCP:Exception,RETURN:sec_file_def,TARGET:ABopenfile}

# Execute the user code
secure_dispatch_module()